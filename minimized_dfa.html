<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFA Minimization Tool</title>
    <style>
        /* Base Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Global Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #2d2d2d;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 1px solid #404040;
        }

        header {
            background: #1a1a1a;
            color: white;
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #404040;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* Desktop Layout (Default) */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr; /* 1/3 for input, 2/3 for viz */
            gap: 30px;
            padding: 30px;
        }

        .section {
            background: #1f1f1f;
            padding: 25px;
            border-radius: 8px;
            border: 2px solid #404040;
        }

        .section h2 {
            color: #ffffff;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 2px solid #555555;
            padding-bottom: 10px;
        }

        /* Input Styles */
        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e0e0e0;
        }

        input[type="text"], select {
            width: 100%;
            padding: 12px;
            border: 2px solid #404040;
            border-radius: 6px;
            font-size: 14px;
            background: #2d2d2d;
            color: #ffffff;
        }

        /* Table Styles */
        .transition-table-container {
            overflow-x: auto; /* Enables horizontal scroll on small screens */
            margin-top: 15px;
        }

        table {
            min-width: 450px; /* Ensures table headers/rows don't collapse */
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            background: #2d2d2d;
        }

        th, td {
            padding: 10px 5px; 
            text-align: center;
            border: 1px solid #404040;
            color: #ffffff;
            font-size: 0.85em; 
        }

        td input {
            width: 100%;
            max-width: 45px; /* Reduced to fit more columns */
            padding: 4px; /* Reduced padding */
            border: 1px solid #404040;
            border-radius: 4px;
            text-align: center;
            background: #1f1f1f;
            color: #ffffff;
            font-size: 0.85em; /* Reduced input text size */
        }

        /* Button Styles */
        .btn {
            background: #ffffff;
            color: #1a1a1a;
            padding: 15px 30px;
            border: 2px solid #ffffff;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #1a1a1a;
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 255, 255, 0.2);
        }

        /* Visualization & Steps Styles */
        .visualization-area {
            display: grid;
            gap: 30px;
        }

        .canvas-container {
            background: #2d2d2d;
            border: 2px solid #404040;
            border-radius: 8px;
            padding: 20px;
            min-height: 350px; 
            position: relative; 
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: #1f1f1f;
            border-radius: 4px;
            width: 100%; 
            height: auto; 
            max-width: 700px;
            max-height: 400px;
        }

        .steps-container {
            background: #2d2d2d;
            border: 2px solid #404040;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px; 
            overflow-y: auto;
        }
        
        /* Step and Partition Elements */
        .group {
            display: inline-block;
            background: #1a1a1a;
            padding: 6px 10px;
            margin: 3px;
            border-radius: 4px;
            border: 1px solid #ffffff;
            color: #ffffff;
            font-size: 0.9em;
        }

        .final-state {
            font-weight: bold;
            color: #28a745;
        }
        
        .hidden {
            display: none;
        }

        /* --- RESPONSIVE MEDIA QUERIES --- */

        /* Tablet and Smaller Laptop Layout (Stacking) */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr; /* Stack vertically */
                gap: 20px;
            }
        }

        /* Phone Layout (600px and below) */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .container {
                border-radius: 0;
            }

            header {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }
            
            .main-content {
                padding: 10px;
                gap: 15px;
            }

            .section {
                padding: 15px;
            }

            .section h2 {
                font-size: 1.2em;
            }
            
            /* CRITICAL FIX: Ensure table container margins are reset and padding is relative to section, allowing table to scroll */
            .transition-table-container {
                /* Inherits overflow-x: auto */
                margin: 15px 0 0 0; /* No negative margins needed here */
                padding: 0;
            }
            
            /* CRITICAL FIX: The table's min-width is the key to scrollability on narrow screens */
            table {
                min-width: 400px; /* Adjusted minimum width */
                width: auto;
            }
            
            th, td {
                padding: 6px 3px;
                font-size: 0.75em;
            }
            
            td input {
                max-width: 35px; /* Further reduction for max compatibility */
                padding: 4px;
            }

            .btn {
                padding: 12px 20px;
                font-size: 14px;
            }

            .canvas-container {
                padding: 10px;
                min-height: 200px;
            }

            .steps-container {
                max-height: 250px;
                padding: 10px;
            }

            .group {
                font-size: 0.75em;
                padding: 4px 7px;
                margin: 2px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ”„ DFA Minimization Tool</h1>
            <p class="subtitle">Visualize and minimize Deterministic Finite Automata using Partition Refinement</p>
        </header>

        <div class="main-content">
            <div class="input-section">
                <div class="section">
                    <h2>DFA Definition</h2>
                    
                    <div class="input-group">
                        <label>States (comma-separated):</label>
                        <input type="text" id="states" placeholder="q0, q1, q2, q3">
                    </div>

                    <div class="input-group">
                        <label>Alphabet (comma-separated):</label>
                        <input type="text" id="alphabet" placeholder="a, b">
                    </div>

                    <div class="input-group">
                        <label>Start State:</label>
                        <select id="startState">
                            <option value="">Select start state</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label>Final States (comma-separated):</label>
                        <input type="text" id="finalStates" placeholder="q2, q3">
                    </div>

                    <div class="transition-table-container">
                        <label>Transition Table:</label>
                        <div id="transitionTableInput"></div>
                    </div>

                    <button class="btn" onclick="processAndVisualize()">Define & Visualize DFA</button>
                    
                    <div id="errorMessage" class="error hidden"></div>
                </div>
            </div>

            <div class="visualization-area">
                <div class="section">
                    <h2>Original DFA</h2>
                    <div class="canvas-container">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                    <div id="originalTable"></div>
                </div>

                <div class="section">
                    <h2>Minimization Steps</h2>
                    <div class="steps-container" id="stepsContainer"></div>
                </div>

                <div class="section">
                    <h2>Minimized DFA</h2>
                    <div id="stateMapping"></div>
                    <div class="canvas-container">
                        <canvas id="minimizedCanvas"></canvas>
                    </div>
                    <div id="minimizedTable"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let dfa = null;
        let minimizedDFA = null;

        // Utility to set canvas dimensions correctly before drawing (CRITICAL FOR RESPONSIVENESS)
        function setCanvasDimensions(canvas) {
            const container = canvas.parentElement;
            const w = container.clientWidth - 40; 
            const h = (w * 400) / 700; // Maintain approx 7:4 aspect ratio
            canvas.width = w;
            canvas.height = h > 400 ? 400 : h;
        }


        // Update transition table when states or alphabet changes
        document.getElementById('states').addEventListener('input', updateTransitionTable);
        document.getElementById('alphabet').addEventListener('input', updateTransitionTable);

        function updateTransitionTable() {
            const statesInput = document.getElementById('states').value;
            const alphabetInput = document.getElementById('alphabet').value;
            
            const states = statesInput.split(',').map(s => s.trim()).filter(s => s);
            const alphabet = alphabetInput.split(',').map(s => s.trim()).filter(s => s);

            // Update start state dropdown
            const startStateSelect = document.getElementById('startState');
            startStateSelect.innerHTML = '<option value="">Select start state</option>';
            states.forEach(state => {
                const option = document.createElement('option');
                option.value = state;
                option.textContent = state;
                startStateSelect.appendChild(option);
            });

            if (states.length === 0 || alphabet.length === 0) {
                document.getElementById('transitionTableInput').innerHTML = '<p style="color: #b0b0b0; font-style: italic;">Enter states and alphabet to generate transition table</p>';
                return;
            }

            // Create transition table
            let tableHTML = '<table><thead><tr><th>State</th>';
            alphabet.forEach(symbol => {
                tableHTML += `<th>Î´(q, ${symbol})</th>`;
            });
            tableHTML += '</tr></thead><tbody>';

            states.forEach(state => {
                tableHTML += `<tr><td><strong>${state}</strong></td>`;
                alphabet.forEach(symbol => {
                    // Pre-fill existing values if available to avoid data loss on table update
                    const existingValue = dfa && dfa.transitions[state] ? dfa.transitions[state][symbol] || '' : '';
                    tableHTML += `<td><input type="text" id="trans_${state}_${symbol}" placeholder="â†’" value="${existingValue}"></td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody></table>';
            document.getElementById('transitionTableInput').innerHTML = tableHTML;
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            setTimeout(() => errorDiv.classList.add('hidden'), 5000);
        }

        function parseDFA() {
            const statesInput = document.getElementById('states').value;
            const alphabetInput = document.getElementById('alphabet').value;
            const startState = document.getElementById('startState').value;
            const finalStatesInput = document.getElementById('finalStates').value;

            const states = statesInput.split(',').map(s => s.trim()).filter(s => s);
            const alphabet = alphabetInput.split(',').map(s => s.trim()).filter(s => s);
            const finalStates = finalStatesInput.split(',').map(s => s.trim()).filter(s => s);

            // Validation
            if (states.length === 0) {
                showError('Please enter at least one state'); return null;
            }
            if (alphabet.length === 0) {
                showError('Please enter at least one alphabet symbol'); return null;
            }
            if (!startState || !states.includes(startState)) {
                showError('Please select a valid start state'); return null;
            }
            for (let fs of finalStates) {
                if (!states.includes(fs)) {
                    showError(`Final state ${fs} is not in the list of states`); return null;
                }
            }

            // Parse transitions
            const transitions = {};
            for (let state of states) {
                transitions[state] = {};
                for (let symbol of alphabet) {
                    const nextState = document.getElementById(`trans_${state}_${symbol}`).value.trim();
                    if (!nextState || !states.includes(nextState)) {
                        showError(`Missing or invalid transition for Î´(${state}, ${symbol})`);
                        return null;
                    }
                    transitions[state][symbol] = nextState;
                }
            }

            return {
                states: new Set(states),
                alphabet: alphabet,
                startState: startState,
                finalStates: new Set(finalStates),
                transitions: transitions
            };
        }

        function drawDFA(canvas, dfa, title = '') {
            setCanvasDimensions(canvas); 
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const states = Array.from(dfa.states);
            const positions = {};
            
            // Dynamic Radius based on screen size/number of states
            const baseRadius = 30;
            const maxRadius = Math.min(canvas.width, canvas.height) / (states.length * 0.7);
            const radius = Math.min(baseRadius, Math.max(15, maxRadius)); 

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const orbitRadius = Math.min(canvas.width, canvas.height) / 2.5;

            // Position states in a circle
            states.forEach((state, i) => {
                const angle = (2 * Math.PI * i) / states.length - Math.PI / 2;
                positions[state] = {
                    x: centerX + orbitRadius * Math.cos(angle),
                    y: centerY + orbitRadius * Math.sin(angle)
                };
            });

            // Draw transitions (Simplified for clarity and responsiveness)
            ctx.strokeStyle = '#e0e0e0';
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '12px Arial';
            ctx.lineWidth = 2;

            const drawnTransitions = new Map();

            // 1. Collect all transitions between state pairs
            states.forEach(fromState => {
                dfa.alphabet.forEach(symbol => {
                    const toState = dfa.transitions[fromState][symbol];
                    const key = fromState < toState ? `${fromState}->${toState}` : `${toState}->${fromState}`;
                    
                    if (!drawnTransitions.has(key)) {
                        drawnTransitions.set(key, { symbols: [], from: fromState, to: toState });
                    }
                    drawnTransitions.get(key).symbols.push(symbol);
                });
            });


            // 2. Draw them
            drawnTransitions.forEach(data => {
                const { from, to, symbols } = data;
                const symbolsText = symbols.join(',');
                const isSelfLoop = from === to;
                
                const fromPos = positions[from];
                const toPos = positions[to];
                
                if (isSelfLoop) {
                    // Self loop
                    ctx.beginPath();
                    ctx.arc(fromPos.x, fromPos.y - radius - 15, 10, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fillText(symbolsText, fromPos.x - 5, fromPos.y - radius - 30);
                } else {
                    const dx = toPos.x - fromPos.x;
                    const dy = toPos.y - fromPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    let cpX = (fromPos.x + toPos.x) / 2;
                    let cpY = (fromPos.y + toPos.y) / 2;

                    // Check for reverse transition to determine curve
                    const reverseKey = `${to}->${from}`;
                    const isBidirectional = drawnTransitions.has(reverseKey);
                    
                    if (isBidirectional && from === data.from) { // Only curve the 'forward' drawn transition
                        const perpAngle = angle + Math.PI / 2;
                        const offset = 20; 
                        cpX += offset * Math.cos(perpAngle);
                        cpY += offset * Math.sin(perpAngle);
                    }
                    
                    const startX = fromPos.x + radius * Math.cos(angle);
                    const startY = fromPos.y + radius * Math.sin(angle);
                    const endX = toPos.x - radius * Math.cos(angle);
                    const endY = toPos.y - radius * Math.sin(angle);


                    // Draw curved arrow
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                    ctx.stroke();

                    // Arrow head
                    const curveAngle = Math.atan2(endY - cpY, endX - cpX);
                    const headlen = 8;
                    
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headlen * Math.cos(curveAngle - Math.PI / 6), endY - headlen * Math.sin(curveAngle - Math.PI / 6));
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - headlen * Math.cos(curveAngle + Math.PI / 6), endY - headlen * Math.sin(curveAngle + Math.PI / 6));
                    ctx.stroke();

                    // Label
                    ctx.fillText(symbolsText, cpX + 5, cpY - 5);
                }
            });


            // Draw start arrow
            const startPos = positions[dfa.startState];
            ctx.beginPath();
            ctx.moveTo(startPos.x - radius - 30, startPos.y);
            ctx.lineTo(startPos.x - radius, startPos.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(startPos.x - radius, startPos.y);
            ctx.lineTo(startPos.x - radius - 10, startPos.y - 5);
            ctx.lineTo(startPos.x - radius - 10, startPos.y + 5);
            ctx.closePath();
            ctx.fill();

            // Draw states
            states.forEach(state => {
                const pos = positions[state];
                const isFinal = dfa.finalStates.has(state);

                // Outer circle for final states
                if (isFinal) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + 5, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                // Main circle
                ctx.strokeStyle = '#ffffff';
                ctx.fillStyle = '#2d2d2d';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // State label
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(state, pos.x, pos.y);
            });
        }

        function displayTransitionTable(dfa, containerId) {
            let html = '<table><thead><tr><th>State</th>';
            dfa.alphabet.forEach(symbol => {
                html += `<th>Î´(q, ${symbol})</th>`;
            });
            html += '</tr></thead><tbody>';

            Array.from(dfa.states).sort().forEach(state => {
                const isFinal = dfa.finalStates.has(state);
                const stateLabel = isFinal ? `<span class="final-state">${state}*</span>` : state;
                html += `<tr><td><strong>${stateLabel}</strong></td>`;
                dfa.alphabet.forEach(symbol => {
                    html += `<td>${dfa.transitions[state][symbol]}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            document.getElementById(containerId).innerHTML = html;
        }

        function minimizeDFA(dfa) {
            const steps = [];
            
            // Initial partition P0
            const nonFinal = Array.from(dfa.states).filter(s => !dfa.finalStates.has(s));
            const final = Array.from(dfa.finalStates);
            
            let partition = [];
            if (nonFinal.length > 0) partition.push(new Set(nonFinal));
            if (final.length > 0) partition.push(new Set(final));

            steps.push({
                partition: partition.map(g => Array.from(g)),
                description: 'Initial partition: separate accepting and non-accepting states',
                splitInfo: null
            });

            let changed = true;
            let iteration = 1;

            while (changed) {
                changed = false;
                const newPartition = [];

                for (let group of partition) {
                    const groupArray = Array.from(group);
                    if (groupArray.length === 1) {
                        newPartition.push(group);
                        continue;
                    }

                    // Try to split this group
                    const subgroups = new Map();
                    let splitOccurred = false;
                    let splitReason = null;

                    for (let state of groupArray) {
                        const signature = dfa.alphabet.map(symbol => {
                            const nextState = dfa.transitions[state][symbol];
                            // Find which group contains nextState
                            for (let i = 0; i < partition.length; i++) {
                                if (partition[i].has(nextState)) return i;
                            }
                            return -1;
                        }).join(',');

                        if (!subgroups.has(signature)) {
                            subgroups.set(signature, []);
                        }
                        subgroups.get(signature).push(state);
                    }

                    if (subgroups.size > 1) {
                        splitOccurred = true;
                        changed = true;

                        // Find what caused the split
                        const signatures = Array.from(subgroups.keys());
                        const sig0 = signatures[0].split(',').map(Number);
                        const sig1 = signatures[1].split(',').map(Number);
                        
                        for (let i = 0; i < dfa.alphabet.length; i++) {
                            if (sig0[i] !== sig1[i]) {
                                const state0 = subgroups.get(signatures[0])[0];
                                const state1 = subgroups.get(signatures[1])[0];
                                splitReason = `States ${state0} and ${state1} transition to different groups on symbol '${dfa.alphabet[i]}'`;
                                break;
                            }
                        }
                    }

                    for (let subgroup of subgroups.values()) {
                        newPartition.push(new Set(subgroup));
                    }

                    if (splitOccurred && splitReason) {
                        steps.push({
                            partition: newPartition.map(g => Array.from(g)),
                            description: `Iteration ${iteration}: Refining partition`,
                            splitInfo: splitReason
                        });
                        iteration++;
                    }
                }

                partition = newPartition;
            }

            if (steps.length === 1 || 
                JSON.stringify(steps[steps.length - 1].partition) !== JSON.stringify(partition.map(g => Array.from(g)))) {
                steps.push({
                    partition: partition.map(g => Array.from(g)),
                    description: 'Final partition: No further refinement possible',
                    splitInfo: null
                });
            }

            return { partition, steps };
        }

        function constructMinimizedDFA(dfa, partition) {
            const stateMapping = new Map();
            const newStates = [];

            partition.forEach((group, idx) => {
                const newStateName = `S${idx}`;
                newStates.push(newStateName);
                group.forEach(state => stateMapping.set(state, newStateName));
            });

            const newTransitions = {};
            const newFinalStates = new Set();
            let newStartState = stateMapping.get(dfa.startState);

            newStates.forEach(newState => {
                newTransitions[newState] = {};
                
                // Find a representative old state
                const oldState = Array.from(stateMapping.entries()).find(([k, v]) => v === newState)[0];
                
                if (dfa.finalStates.has(oldState)) {
                    newFinalStates.add(newState);
                }

                dfa.alphabet.forEach(symbol => {
                    const nextOldState = dfa.transitions[oldState][symbol];
                    newTransitions[newState][symbol] = stateMapping.get(nextOldState);
                });
            });

            return {
                dfa: {
                    states: new Set(newStates),
                    alphabet: dfa.alphabet,
                    startState: newStartState,
                    finalStates: newFinalStates,
                    transitions: newTransitions
                },
                stateMapping: stateMapping,
                groups: partition
            };
        }

        function displaySteps(steps) {
            let html = '';
            steps.forEach((step, idx) => {
                html += `<div class="step">`;
                html += `<div class="step-title">P${idx}: ${step.description}</div>`;
                html += `<div class="partition">`;
                step.partition.forEach(group => {
                    html += `<span class="group">{${group.join(', ')}}</span>`;
                });
                html += `</div>`;
                if (step.splitInfo) {
                    html += `<div class="split-reason">Split reason: ${step.splitInfo}</div>`;
                }
                html += `</div>`;
            });
            document.getElementById('stepsContainer').innerHTML = html;
        }

        function displayStateMapping(stateMapping, groups) {
            let html = '<div class="state-mapping"><h3>State Mapping</h3>';
            groups.forEach((group, idx) => {
                const newState = `S${idx}`;
                html += `<div class="mapping-item">${newState} = {${Array.from(group).join(', ')}}</div>`;
            });
            html += '</div>';
            document.getElementById('stateMapping').innerHTML = html;
        }

        function processAndVisualize() {
            dfa = parseDFA();
            if (!dfa) return;

            // Display original DFA
            drawDFA(document.getElementById('originalCanvas'), dfa, 'Original DFA');
            displayTransitionTable(dfa, 'originalTable');

            // Minimize DFA
            const { partition, steps } = minimizeDFA(dfa);
            displaySteps(steps);

            // Construct and display minimized DFA
            const result = constructMinimizedDFA(dfa, partition);
            minimizedDFA = result.dfa;
            
            displayStateMapping(result.stateMapping, result.groups);
            drawDFA(document.getElementById('minimizedCanvas'), minimizedDFA, 'Minimized DFA');
            displayTransitionTable(minimizedDFA, 'minimizedTable');
        }
        
        // Ensure canvas redraws on resize (CRITICAL FOR RESPONSIVENESS)
        window.addEventListener('resize', () => {
             if (dfa) {
                drawDFA(document.getElementById('originalCanvas'), dfa, 'Original DFA');
             }
             if (minimizedDFA) {
                drawDFA(document.getElementById('minimizedCanvas'), minimizedDFA, 'Minimized DFA');
             }
        });


        // Initialize with example
        window.onload = function() {
            document.getElementById('states').value = 'q0, q1, q2, q3, q4, q5';
            document.getElementById('alphabet').value = 'a, b';
            document.getElementById('finalStates').value = 'q5';
            updateTransitionTable();
            
            // Use setTimeout to ensure DOM is fully ready and select options are populated
            setTimeout(() => {
                document.getElementById('startState').value = 'q0';
                document.getElementById('trans_q0_a').value = 'q1';
                document.getElementById('trans_q0_b').value = 'q2';
                document.getElementById('trans_q1_a').value = 'q3';
                document.getElementById('trans_q1_b').value = 'q4';
                document.getElementById('trans_q2_a').value = 'q3';
                document.getElementById('trans_q2_b').value = 'q4';
                document.getElementById('trans_q3_a').value = 'q5';
                document.getElementById('trans_q3_b').value = 'q5';
                document.getElementById('trans_q4_a').value = 'q5';
                document.getElementById('trans_q4_b').value = 'q5';
                document.getElementById('trans_q5_a').value = 'q5';
                document.getElementById('trans_q5_b').value = 'q5';
                
                // Automatically visualize the example on load
                processAndVisualize(); 
            }, 100);
        };
    </script>
</body>
</html>